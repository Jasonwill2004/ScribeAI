/**
 * Download API Route
 * Generates a downloadable file with session transcript and summary
 */

import { NextRequest, NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export async function GET(
  request: NextRequest,
  { params }: { params: { sessionId: string } }
) {
  try {
    const { sessionId } = params

    // Fetch session with all related data
    const session = await prisma.session.findUnique({
      where: { id: sessionId },
      include: {
        transcriptChunks: {
          orderBy: { chunkIndex: 'asc' }
        },
        summary: true,
        user: {
          select: {
            name: true,
            email: true
          }
        }
      }
    })

    if (!session) {
      return NextResponse.json(
        { error: 'Session not found' },
        { status: 404 }
      )
    }

    // Format the download content
    const formatDate = (date: Date) => {
      return new Intl.DateTimeFormat('en-US', {
        dateStyle: 'full',
        timeStyle: 'long'
      }).format(new Date(date))
    }

    const formatDuration = (seconds: number | null) => {
      if (!seconds) return 'N/A'
      const mins = Math.floor(seconds / 60)
      const secs = seconds % 60
      return `${mins} minutes ${secs} seconds`
    }

    // Build the transcript content
    let content = `SCRIBE AI SESSION TRANSCRIPT
${'='.repeat(80)}

SESSION INFORMATION
-------------------
Title: ${session.title || 'Untitled Session'}
Started: ${formatDate(session.startedAt)}
Ended: ${session.endedAt ? formatDate(session.endedAt) : 'In Progress'}
Duration: ${formatDuration(session.durationSec)}
Status: ${session.state.toUpperCase()}
Session ID: ${session.id}

`

    // Add summary if available
    if (session.summary) {
      content += `AI SUMMARY
${'='.repeat(80)}

${session.summary.content}

`

      if (session.summary.keyPoints.length > 0) {
        content += `KEY POINTS
----------
${session.summary.keyPoints.map((point, i) => `${i + 1}. ${point}`).join('\n')}

`
      }

      if (session.summary.actionItems.length > 0) {
        content += `ACTION ITEMS
------------
${session.summary.actionItems.map((item, i) => `${i + 1}. ${item}`).join('\n')}

`
      }
    }

    // Add full transcript
    content += `FULL TRANSCRIPT
${'='.repeat(80)}

`

    if (session.transcriptChunks.length === 0) {
      content += 'No transcript available.\n'
    } else {
      session.transcriptChunks.forEach((chunk) => {
        const timestamp = formatDate(chunk.timestamp)
        const speaker = chunk.speaker ? `[${chunk.speaker}] ` : ''
        content += `[Chunk #${chunk.chunkIndex + 1} - ${timestamp}]\n${speaker}${chunk.text}\n\n`
      })
    }

    content += `${'='.repeat(80)}
Generated by ScribeAI on ${formatDate(new Date())}
`

    // Return as downloadable text file
    const filename = `scribeai-${session.title?.toLowerCase().replace(/\s+/g, '-') || 'session'}-${session.id.substring(0, 8)}.txt`

    return new NextResponse(content, {
      headers: {
        'Content-Type': 'text/plain; charset=utf-8',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Cache-Control': 'no-cache'
      }
    })
  } catch (error) {
    console.error('Download error:', error)
    return NextResponse.json(
      { error: 'Failed to generate download' },
      { status: 500 }
    )
  }
}
